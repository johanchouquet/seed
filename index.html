<html>
    <head>
        <title>WireMail Tutorial</title>
        <link rel="stylesheet" href="style.css" />
        <script src="lib/jquery/jquery.js"></script>
        <link rel="stylesheet" href="lib/highlightjs/styles/github.css">
        <script src="lib/highlightjs/highlight.pack.js"></script>
        <script>
        $(function(){
            $('pre code.html').each(function(){
                var html = $(this).html();
                html = html.replace(/.*<!--.*[\n\r]/,'');
                html = html.replace(/\n.*-->.*/,'');
                console.log(html);
                $(this).text(html);
            });
            hljs.initHighlightingOnLoad();
        });
        </script>
    </head>
    <body>
        <h1>Wire Mail Tutorial</h1>

        <h2>Contents</h2>
        <ul>
            <li><a href="#intro">wire.js - benefits</a></li>
            <li><a href="#step0">step 0 - get repo and install requirements</a></li>
            <li><a href="#step1">step 1 - start your environment</a></li>
            <li><a href="#step2">step 2 - create a view</a></li>
            <li><a href="#step3">step 3 - connect up some data</a></li>
        </ul>

        <h2 id="intro">wire.js - benefits: a structured environment for you app</h2>
        <table class="benefits">
            <tbody>
                <tr>
                    <td>
                        1 - Be Modular
                        <ul>
                            <li>Create the boxes in your systems diagram in one place</li>
                        </ul>
                    </td>
                    <td class="image"><img src="images/1-modular.png"></td>
                    <td>
                        <ul>
                            <li>No bootstrap!</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>
                        2 - Connect Your Modules
                        <ul>
                            <li>Draw the lines in your systems diagram</li>
                        </ul>
                    </td>
                    <td class="image"><img src="images/2-connect.png"></td>
                    <td>
                        <ul>
                            <li>No manual connection code!</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>
                        3 - Inject Their Dependencies
                        <ul>
                            <li>Inject dependent modules instead of having hard coded instatiation inside</li>
                        </ul>
                    </td>
                    <td class="image"><img src="images/3-inject.png"></td>
                    <td>
                        <ul>
                            <li>No manual dependency resolution!</li>
                            <li>More testable modules</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>
                        4 - Control Their Lifecycle
                        <ul>
                            <li>Control how the right things happen at the right time</li>
                        </ul>
                    </td>
                    <td class="image"><img src="images/4-lifecycle.png"></td>
                    <td>
                        <ul>
                            <li>Ensure each component is cleaned up</li>
                        </ul>
                    </td>
                </tr>
            </tbody>
        </table>

        <h2 id="step0">step 0 - get repo and install requirements</h2>
        <p>
            For best results you'll want to fetch the tutorial so you can play along. We use git for source control. When you have git just clone this repo like so:
        </p>

        <pre><code class="no-highlight">
    git clone git@github.com:gehan/seed.git
    git checkout wire
        </code></pre>

        <p>
            To run the webserver and install our libraries we use node.js. When you have node just go to the root of this repo and run this to download everything:
        </p>

        <pre><code class="no-highlight">
    npm install
        </code></pre>

        <p>
            This will install a small webserver, our js package manager bower, and download all the libraries. To start the server run:
        </p>

        <pre><code class="no-highlight">
    npm start
        </code></pre>

        <p>
            Point your browser (Chrome ideally) to http://localhost:8000/. If you open the console in developer tools you should see this:
        </p>

        <pre><code class="no-highlight">
    Spec loading OK! Context available as 'context'
        </code></pre>

        <p>
            After this you're all ready to go! Head to step 1 to get building this app!
        </p>

        <h2 id="step1">step 1 - your new environment!</h2>
        <p>
            An empty wire environment should be running. Let's quickly explain how this is happening before we move onto something more visible! However first make sure you're on the right branch:
        </p>

        <pre><code class="no-highlight">
    git checkout wire
        </code></pre>


        <p>
            Next we'll trace our way from index.html through to how wire starts.
        </p>

        <h3>index.html - minimal shell for app</h3>

        <p>Your index.html looks quite small doesn't it? It now serves as a minimal shell to start up your app. We just import our AMD loader (curl) and another file run.js</p>

        <pre><code class="html">
        <!--
            <!DOCTYPE html>
            <html>
                <head>
                    <title>Seed App</title>
                    <script src="/lib/curl/src/curl.js"></script>
                    <script src="/app/run.js"></script>
                </head>
                <body>
                </body>
            </html>
        -->
        </code></pre>

        <h3>run.js - configure your packages and start the app</h3>

        <p>Here we define any AMD packages we are going to use, and start up our wire spec!</p>

        <pre><code class="javascript">
    (function(curl){

        // Configure all our module paths
        var config = {
            paths: {
                'jquery': 'lib/jquery/jquery'
            },
            packages: [
                { name: 'curl', location: 'lib/curl/src/curl' },
                { name: 'wire', location: 'lib/wire', main: 'wire' },
                { name: 'meld', location: 'lib/meld', main: 'meld' },
                { name: 'when', location: 'lib/when', main: 'when' },
                { name: 'poly', location: 'lib/poly' }
            ]
        };

        // Start up the app! Runs our app/spec.js through wire.
        curl(config, ['wire!app/spec']);

    })(curl);
        </code></pre>

        <p>Almost done, however the wire! plugin returns a promise, so let's add the success and failure handlers so we can look inside and handle any errors that arise</p>

        <pre><code class="javascript">
    (function(curl){

        // Configure all our module paths
        var config = {
            paths: {
                'jquery': 'lib/jquery/jquery'
            },
            packages: [
                { name: 'curl', location: 'lib/curl/src/curl' },
                { name: 'wire', location: 'lib/wire', main: 'wire' },
                { name: 'meld', location: 'lib/meld', main: 'meld' },
                { name: 'when', location: 'lib/when', main: 'when' },
                { name: 'poly', location: 'lib/poly' }
            ]
        };

        // If our app starts correctly then log and make the context available
        var success = function (context) {
            console.log('Spec loading OK! Context available as \'context\'');
            window.context = context;
        };

        // If something goes wrong then we log that error
        var fail = function (error) {
            console.log('Error loading spec');
            console.error(error.stack);
        };

        // Start up the app! Runs our app/spec.js through wire. Curl is
        // promise-based so we can pass the result to our success/failure handlers
        curl(config, ['wire!app/spec']).then(success, fail);

    })(curl);
        </code></pre>

        <h3>spec.js - our wire environment</h3>

        <p>Finally, let's introduce our first key concept - the <strong>spec</strong>:</p>

        <pre><code class="javascript">
    define({

        hello: 'world'

    });
        </code></pre>

        <p>Ok this doesn't do a lot, but this is where you specify what your app does - what components are in it an what they do.</p>

        <p>When you run a spec, wire creates all these components and outputs a <strong>context</strong> object. If you looked closely at the run.js you'll see that window.context has been set. If you type 'context.hello' in the console you should now get 'world'.</p>
        <p>This will make more sense when there is something more substantial in it - so on to step 2!</p>

        <h2 id="step2">step 2 - create a view</h2>

        <p>First move to the next branch</p>

        <pre><code class="no-highlight">
    git checkout wire-html
        </code></pre>

        <p>
            To start showing what can be in a spec, let's load up some good old html and css for our Mail App. We'll start with a static template and make it dynamic later.
        </p>

        <p>New files:</p>
        <ul>
            <li><a href="https://github.com/gehan/seed/blob/wire-html/app/layout.html">app/layout.html</a></li>
            <li><a href="https://github.com/gehan/seed/blob/wire-html/app/layout.css">app/layout.css</a></li>
        </ul>

        <p>So how do we get these into the DOM without touching index.html?</p>

        <p>Well before that, we'd like to introduct you to <strong>components</strong> - the central concept in IOC.</p>

        <p>In the last example the wire spec actually had a component called 'hello', however this was just set to a string literal. That's not that useful, however we can also load AMD modules as components. In the below example we are loading the normalize.css file as a module.</p>

        <pre><code class="javascript">
    define({
        // Normalise browser environment using normalize.css
        reset: {
            module: 'css!lib/normalize-css/normalize.css'
        }
    });
        </code></pre>

        <p>The css! plugin will also inject the stylesheet into the DOM. Pretty handy as you don't have to add css files to your html files directly any more.</p>

        <p>So what about out html file? For this we need to introduce another concept - <strong>factories</strong></p>

        <p>Factories allow wire to instatiate objects, such as the render factory in this case which allows wire to create DOM nodes. Here we set template to our layout.html - notice how we use the same {module: ''} format as with the reset component.</p>

        <pre><code class="javascript">
    define({
        // Normalise browser environment using normalize.css
        reset: {
            module: 'css!lib/normalize-css/normalize.css'
        },

        // Create basic layout
        layout: {
            render: {
                template: {
                    module: 'text!app/layout.html'
                }
            }
        },

        plugins: ['wire/dom', 'wire/dom/render']

    });
        </code></pre>

        <p>If you looked at context object here you'd see that context.layout in now in fact a DOM node, but how do we get it in the DOM?. Well the render factory also provides the insert <strong>facet</strong>. We can specific that we want to insert the dom node at a particular location, using our first bit of dependency injection.</p>

        <p>The funny $ref object below tells wire that it is a reference that needs resolving, which in this case is a dom node. It is being instructed to the first node that matches the selector body - which will be the body tag naturally.</p>

        <p>You'll notice that another css property has appears in the render factory. This will also load the layout.css stylesheet, and provides a tidy way to keep template and stylsheet together.</p>

        <p>Finally you can see the plugins array at the bottom of the spec, in this case to use the render factory. wire.js has a powerful plugin architecture which we'll come to later on.</p>

        <pre><code class="javascript">
    define({
        // Normalise browser environment using normalize.css
        reset: {
            module: 'css!lib/normalize-css/normalize.css'
        },

        // Create basic layout
        layout: {
            render: {
                template: {
                    module: 'text!app/layout.html'
                },
                css: {
                    module: 'css!app/layout.css'
                }
            },
            insert: {
                at: {
                    $ref: 'dom.first!body'
                }
            }
        },

        plugins: ['wire/dom', 'wire/dom/render']

    });
        </code></pre>

        <h2 id="step3">step 3 - connect up some data</h2>

        <p>First move to the next branch</p>

        <pre><code class="no-highlight">
    git checkout wire-view
        </code></pre>

        <p>New files:</p>
        <ul>
            <li><a href="https://github.com/gehan/seed/blob/wire-view/app/EmailPreviewView.js">app/EmailPreviewView.js</a></li>
            <li><a href="https://github.com/gehan/seed/blob/wire-view/app/main-content.html">app/main-content.html</a></li>
            <li><a href="https://github.com/gehan/seed/blob/wire-view/app/EmailPreviewsCollection.js">app/EmailPreviewsCollection.js</a></li>
        </ul>

        <p>
            We'll use Backbone here to allow us to knock up a dynamic view using a template, and then add in some data with a collection. So let's start by adding a view to the spec. Rather than show the whole spec we'll show it on it's own for clarity:
        </p>

        <pre><code class="javascript">
        emailPreviewView: {
            create: {
                module: 'app/EmailPreviewView',
                args:[{
                    el: {
                        $ref: 'dom.first!.main-content',
                        at: 'layout'
                    }
                }]
            },
            properties: {
                template: {
                    module: 'text!app/main-content.html'
                }
            }
        }
        </code></pre>

        <p>There are a few things going on here so let's go through them one by one.</p>

        <p>First we have a new factory - the create factory. Using the same module syntax as before we are instructing wire to take that module and create a new instance of it. So if the class returns SomeObj, it'll effectively called new SomeObj().</p>

        <p>What we can also do is provide an array of arguments for the constructor. In this case just the one argument, which is an object {el: ...}. You'll notice the funny $ref syntax again, which means we're providing a reference to another object. This is like the $ref we used before - except we are now telling wire not to select from the whole dom, but just from the layout component.</p>

        <p>Finally you'll notice the properties facet - this is another bit of dependency injection at work. For each key in the properties object, the value will be injected as the same key in emailPreviewView. So here emailPreviewView.template will be set to the main-content.html file. Note this is different from the render factory, and will only be a string of the contents of main-content.html. This can be very powerful as you can inject other components like this using the $ref syntax (show later)</p>

        <p>Now we have a simple view, so let's put some data in so the view has something to render! Again rather than print the whole spec we'll just show the new part</p>

        <pre><code class="javascript">
        emailPreviewCollection: {
            create: {
                module: 'app/EmailPreviewsCollection'
            },
            properties: {
                url: 'app/emailPreviews.json'
            },
            ready: 'fetch',
            after: {
                fetch: 'emailPreviewView.render'
            }
        },
        plugins: ['wire/dom', 'wire/dom/render', 'wire/aop']
        </code></pre>


        <p>There are a few more concepts introduce here, so again let's go through them one by one. Like the view we're creating an object and injecting a property, in this case just a string value for the url.</p>

        <p>The next thing you'll notice is the ready facet. </p>

    </body>
</html>
